We monitor all sockets with poll.
If nothing is happening, we wait.
If something happens — a new client wants to connect, or an old one wants to send/read — poll tells us exactly who wants what.
We respond to it. Then repeat.
This way, we efficiently serve many clients without wasting CPU, without threads, and only reacting when needed.

//NOTE IN REQUEST RESPONSE PROTOCOL
THERE must be Persist application state between loop iterations. For request-response protocols,
 alternate between 2 states (read and write).
handle_write and handle_read should alter the state accordingly. had trouble with this 


//PIPELING
does not decrease time to process one request
but different stages of read write are idle when one is in different stage.
decrease time for n request n response
implemetation 
handle_read() assumes that there is at most 1 request in the input buffer. 
After it has processed 1 request, the logic continues with handle_write(), 
and after it’s done, handle_write() asks the event loop to wait for more data, even 
though there is still unhandled data in the input buffer. So the pipeline is stuck!

the TCP byte stream is a major obstacle to network programming. A server cannot handle 
pipelined requests without interpreting the byte stream correctly.
1.TCP does not preserve message boundaries: requests can mix and overlap
2.pipelineing requires able to distinguish requests
3.use of delimeters, length prefix etc careful and complex parsing


/////client side
the client sees the response as a single continuous byte stream, regardless of how many times 
the server writes to the kernel buffer or how the data is split into packets.

TCP guarantees in-order, reliable delivery of bytes.
The client’s recv or read calls may return data in any chunk sizes, but the data will be in 
the exact order sent.
The client cannot tell how the server’s writes were split; it just receives a stream of bytes.
From the client’s perspective, the response is always a single, ordered stream of bytes,
 even if the server sent it in multiple parts.





 //syscall trace using strace in linux

//replace vector which is FIFO to a more dynamic container with constant time front delete and append for a single element.

